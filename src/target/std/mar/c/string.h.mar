;;/
;; Implements the C header 'string.h' file in MAR assembly
;; NOTE: all functions and variables are prefixed with `__c_`
;; NOTE: all constants are prefixed with `__C_`
;; Source: https://pubs.opengroup.org/onlinepubs/007908799/xsh/string.h.html
;;         http://www.cplusplus.com/reference/cstring/
;;/

__C_NULL equ 0x0000

;; void * memchr (const void * haystack, int needle, size_t length);
__c_memchr:
    push bp
    mov bp, sp

    ;; [BP] = bp
    ;; [BP + 1] = return address
    ;; [BP + 2] = const void * haystack
    ;; [BP + 3] = int needle
    ;; [BP + 4] = size_t length
    mov a, [BP + 2]
__c_memchr_loop:
    cmp [BP + 4], 0
    jz __c_memchr_return_null
    cmp [a], [BP + 3]
    jz __c_memchr_return
    inc a
    dec [BP + 4]
    jmp __c_memchr_loop
__c_memchr_return_null:
    xor a, a
__c_memchr_return:
    mov sp, bp
    pop bp
    ret 3

;; int memcmp(const void * lhs, const void * rhs, size_t length);
__c_memcmp:
    push b
    push c
    push bp
    mov bp, sp

    ;; [BP] = bp
    ;; [BP + 1] = c
    ;; [BP + 2] = b
    ;; [BP + 3] = return address
    ;; [BP + 4] = const void * lhs
    ;; [BP + 5] = const void * rhs
    ;; [BP + 6] = size_t length
    mov b, [BP + 4]
    mov c, [BP + 5]
    xor a, a
__c_memcmp_loop:
    cmp [bp + 6], 0
    jz __c_memcmp_return
    mov a, [c]
    sub a, [b]
    jnz __c_memcmp_return
    inc b
    inc c
    dec [BP + 6]
    jmp __c_memcmp_loop
__c_memcmp_return:
    mov sp, bp
    pop bp
    pop c
    pop b
    ret 3

;; void * memcpy(void * destination, const void * source, size_t length);
__c_memcpy:
    push b
    push bp
    mov bp, sp
    
    ;; [BP] = bp
    ;; [BP + 1] = b
    ;; [BP + 2] = return value
    ;; [BP + 3] = void * destination
    ;; [BP + 4] = void * source
    ;; [BP + 5] = size_t length
    mov a, [BP + 3]
    mov b, [BP + 4]
__c_memcpy_loop:
    cmp [BP + 5], 0
    jz __c_memcpy_return
    mov [a], [b]
    inc a
    inc b
    dec [BP + 5]

__c_memcpy_return:
    mov a, [BP + 3]
    mov sp, bp
    pop bp
    ret 3

;; void *memmove(void *, const void *, size_t);
__c_memmove:
    mov a, __C_NULL
    ret 3

;; void * memset(void *, int, size_t);
__c_memset:
    mov a, __C_NULL
    ret 2

;; char * strcat(char *, const char *);
__c_strcat:
    mov a, __C_NULL
    ret 2

;; char * strchr(const char *, int);
__c_strchr:
    mov a, __C_NULL
    ret 2

;; int strcmp(const char *, const char *);
__c_strcmp:
    mov a, __C_NULL
    ret 2

;; char * strcpy(char *, const char *);
__c_strcpy:
    mov a, __C_NULL
    ret 2

;; size_t strcspn(const char *, const char *);
__c_strcspn:
    mov a, __C_NULL
    ret 2

;; char * strerror(int);
__c_strerror:
    mov a, __C_NULL
    ret 1

;; size_t __c_strlen(const char * str);
__c_strlen:
    push bp
    mov bp, sp
    ;; [BP + 0] = old BP
    ;; [BP + 1] = return address
    ;; [BP + 2] = const char * str
    mov a, [bp + 2]
__c_strlen_loop:
    cmp [a], 0
    jz __c_strlen_return
    inc a
    jmp __c_strlen_loop
__c_strlen_return:
    sub a, [bp + 2]
    mov sp, bp
    pop bp
    ret 1

;; char * strncat(char *, const char *, size_t);
__c_strncat:
    mov a, __C_NULL
    ret 3

;; int strncmp(const char *, const char *, size_t);
__c_strncmp:
    mov a, __C_NULL
    ret 3

;; char * strncpy(char *, const char *, size_t);
__c_strncpy:
    mov a, __C_NULL
    ret 3

;; char * strpbrk(const char *, const char *);
__c_strpbrk:
    mov a, __C_NULL
    ret 2

;; char * strrchr(const char *, int);
__c_strrchr:
    mov a, __C_NULL
    ret 2

;; size_t strspn(const char *, const char *);
__c_strspn:
    mov a, __C_NULL
    ret 2

;; char * strstr(const char *, const char *);
__c_strstr:
    mov a, __C_NULL
    ret 2

;; char * strtok(char *, const char *);
__c_strtok:
    mov a, __C_NULL
    ret 2

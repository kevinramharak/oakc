;; std.mar
;; standard library implementation

;; __oak_stdlib_printf(const char * format, ...args)
;; 
__oak_stdlib_printf:
    PUSH BP
    MOV BP, SP
    MOV SP, BP
    POP BP
    RET

;; pop a value and print it at a string
;; void prs!(s)
;; https://github.com/simon987/Much-Assembly-Required/wiki/(Hardware)-Universal-Com-Port
prs:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    MOV B, [machine_memory]     ; int * loc = machine->memory
    CALL machine_pop            ; int offset = machine_pop()
    ADD B, A                    ; loc += offset
    PUSH B
    CALL _comport_self_out_write
prs_break:
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void prn!(n)
;; implementation from: https://stackoverflow.com/a/3982700
;; no negative numbers, no bound checks
prn:
    PUSH A
    PUSH B
    PUSH Y
    PUSH BP
    MOV BP, SP
    CALL machine_pop  ; pop value into
    MOV B, prn_buffer ; char * loc = &prn_buffer
    ADD B, 4          ; loc += 4 // move to the end of the buffer, but before the null terminator
prn_loop:
    CMP A, 10         ; while (value >= 10)
    JL prn_break
    MOV Y, 0         ; zero out Y for the DIV op
    DIV 10           ; divide by 10, result in A, remainder in Y
    ADD Y, 0x30      ; convert remainder to ascii character
    MOV [B], Y       ;
    DEC B
    JMP prn_loop
prn_break:
    ADD A, 0x30
    MOV [B], A
prn_loop_prc:
    PUSH B
    CALL _comport_self_out_write
prn_return:
    MOV SP, BP
    POP BP
    POP Y
    POP B
    POP A
    RET
prn_buffer: DW 6 DUP(0x00) ; space for 5 character + '\0'

;; void prc!(ch)
prc:
    PUSH A
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV [prc_buffer], A
    PUSH prc_buffer
    CALL _comport_self_out_write
    MOV SP, BP
    POP BP
    POP A
    RET
prc_buffer: DW 2 DUP(0x00) ;; snice the second word is never written to, this will always be a string with 1 character + null terminator


;; void _prn(n) ;; uses MAR stackc instead of virtual machine
;; implementation from: https://stackoverflow.com/a/3982700
;; no negative numbers, no bound checks
_prn:
    PUSH A
    PUSH B
    PUSH Y
    PUSH BP
    MOV BP, SP
    MOV A, [BP + 5]
    MOV B, _prn_buffer ; char * loc = &prn_buffer
    ADD B, 4          ; loc += 4 // move to the end of the buffer, but before the null terminator
_prn_loop:
    CMP A, 10         ; while (value >= 10)
    JL _prn_break
    MOV Y, 0         ; zero out Y for the DIV op
    DIV 10           ; divide by 10, result in A, remainder in Y
    ADD Y, 0x30      ; convert remainder to ascii character
    MOV [B], Y       ;
    DEC B
    JMP _prn_loop
_prn_break:
    ADD A, 0x30
    MOV [B], A
_prn_loop_prc:
    PUSH B
    CALL _comport_self_out_write
_prn_return:
    MOV SP, BP
    POP BP
    POP Y
    POP B
    POP A
    RET 1
_prn_buffer: DW 5 DUP(0x00), "\n", 0x00 ; space for 5 character + '\0'

;; this function seems to be missing from std.ok, but is used in a few files
;; it prints a newline
;; void prend!()
prend:
    PUSH 10 ; '\n'
    CALL machine_push
    CALL prc
    RET

;; retrieve a character from stdin and push it on the stack
;; void getch!()
;; NOTE: seems like getch is expected to block so we emulate that behaviour
;; https://github.com/simon987/Much-Assembly-Required/wiki/(Hardware)-Keyboard
getch:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
getch_fetch:
    MOV A, KEYBOARD_FETCH_KEY
    HWI HWID_KEYBOARD
    CMP B, 0   ; if the result is zero there was no character in the keyboard buffer
    JNZ getch_newline_check
    CALL _sleep ; to prevent spinning and draining the server / have the server terminate our execution we use sleep
    JMP getch_fetch
getch_newline_check:
    ;; NOTE: oakc examples ignore '\r' and work with '\n' characters, so we do a switcheroo
    CMP B, 13 ;; if key is a '\r' character, replace it with a '\n' character
    JNZ getch_return
    MOV B, 10
getch_return:
    PUSH B
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

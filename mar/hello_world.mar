;; data segment - for now assumed that .data starts at adress 0x00
.data
    DW 50 DUP(0x00) ; padding to be able to adress the following 3 labels
    ;; see https://github.com/simon987/Much-Assembly-Required/blob/master/Server/src/main/java/net/simon987/server/assembly/CPU.java#L194
    EXECUTION_COST_ADDR: DW 0x0000
    ;; 32 bit signed integer
    EXECUTED_INSTRUCTION_COUNT_HIGHER: DW 0x0000
    EXECUTED_INSTRUCTION_COUNT_LOWER: DW 0x0000

    ;; TODO: these variables can be moved into the first 50 words
    ;; _sleep variables
    should_wake:  DW 0x0000
    BP_cache: DW 0x0000
    SP_cache: DW 0x0000

;; default origin of .text is 0x200, can be manipulated with ORG directive
;; execution on a server tick always starts at .text, on a server reset memory will be cleared
.text
    ;; if flag is set restore from previous sleep call
    CMP [should_wake], 1
    JZ _wake
    ;; else spin up a vm implementation
    CALL machine_new

    ;; call main
    ;; could push int argc, char ** argv, char ** env on the stack?
    CALL main
    ;; if returning from main spin with a sleep call
_spin:
    CALL _sleep
    JMP _spin

;; simple debug function to print a value to the buffer
_debug:
    MOV [_debuf_buffer], A
_debug_loop:
    MOV A, 3
    MOV X, _debuf_buffer
    HWI 0x000D
    CALL _sleep
    JMP _debug_loop
_debuf_buffer: DW 8 DUP(0x20)

;; sleep and wake implementation
;; allows to control execution start each server tick
;; if sleep isnt used, execution will always start at .text
_sleep:
    ;; not sure if registers are preserved between each game tick, sleep will preserve all state
    PUSHF                   ;; store flags
    PUSH A                  ;; store registers
    PUSH B
    PUSH C
    PUSH D
    PUSH X
    PUSH Y
    MOV [BP_cache], BP      ;; store stack base pointer and stack pointer
    MOV [SP_cache], SP
    MOV [should_wake], 1    ;; set the flag
    BRK                     ;; wait till next tick
_wake:                      ;; execution will resume here
    MOV [should_wake], 0    ;; clear the flag
    MOV SP, [SP_cache]      ;; restore stack base pointer and stack pointer
    MOV BP, [BP_cache]
    POP Y                   ;; restore registers
    POP X
    POP D
    POP C
    POP B
    POP A
    POPF                    ;; restore flags
    ;; since `CALL sleep` never executed a RET instruction this will restore execution after the most recent executed `CALL sleep` instruction
    RET

;; void panic(int code); // fatal error handler, always exists program
;; TODO: the strings can probably be allocated in the first 50 bytes
STACK_HEAP_COLLISION EQU 1
NO_FREE_MEMORY EQU 2
STACK_UNDERFLOW EQU 3
_panic_default_message: DW "unkown error code", 0
_panic_stack_heap_collision: DW "stack and heap collision during push", 0
_panic_no_free_memory: DW "no free memory left", 0
_panic_stack_underflow: DW "stack underflow", 0
_panic:
    PUSH BP
    MOV BP, SP
    MOV A, [BP + 2]
    MOV C, _panic_default_message
    ;; stack and heap collision
_panic_case_1:
    CMP A, 1
    JNZ _panic_case_2
    MOV C, _panic_stack_heap_collision
    JMP _panic_spin
_panic_case_2:
    CMP A, 2
    JNZ _panic_case_3
    MOV C, _panic_no_free_memory
    JMP _panic_spin
_panic_case_3:
    CMP A, 3
    JMP _panic_spin
    MOV C, _panic_stack_underflow
_panic_spin:
    MOV A, 3
    MOV X, C
    HWI 0x000D
    CALL _sleep
    JMP _panic_spin

;; TODO: the memory allocation is really primitive, definitly need something more effecient
;; virtual machine implementation
;; based on the vm implementation in 'std.c'
STACK_START equ 0xffff ; stack pointer starts at mem[65535] goes towards mem[0]
; heap_start: dw 0 ; is a label generated at the end 
;; struct machine {}
machine_memory: DW 0x0000 ; int * memory
machine_allocated: DW 0x0000 ; bool * allocated
machine_capacity: DW 0x0000 ; int capacity
machine_stack_ptr: DW 0x0000 ; int stack_ptr
machine_new: ; machine * machine_new ( int var, int capacity )
    ;; TODO: write an heap implementation that doesnt have a 100% memory overhead
    MOV A, STACK_START
    SUB A, HEAP_START ; memory open to use
    SUB A, 0x1000     ; keep 0x1000 open for the stack ;; TODO: make sure stack and heap dont colide
    SHR A, 1          ; divide it by 2
    MOV [machine_capacity], A           ;; so capacity is (STACK_START - HEAP_START) / 2
    MOV [machine_memory], HEAP_START    ;; machine->memory is a pointer to the HEAP_START address
    MOV [machine_allocated], HEAP_START ;; machine->allocated  is a pointer to the HEAP_START address with an offset of (STACK_START - HEAP_START) / 2
    ADD [machine_allocated], [machine_capacity]
    ;; compiler figures out maximum stack size and defines it as a constant
    ;; the c impl does a for loop with push(0) for this size, but the end result is the same as setting the stack ptr to this size
    MOV [machine_stack_ptr], [_machine_new_vars]
    RET

;; void machine_allocate()
;; pop size of the stack
machine_allocate:
    PUSH A
    PUSH B
    PUSH C
    PUSH D
    PUSH X
    PUSH Y
    PUSH BP
    MOV BP, SP
    CALL machine_pop           ; int size = machine_pop()
    MOV B, [machine_capacity]  ; int i = machine->capacity
    DEC B                      ; i -= 1
    MOV C, [machine_allocated] ; int * loc_allocated = machine->allocated
    MOV X, 0                   ; int consecutive_free_cells = 0
machine_allocate_loop_find:
    CMP B, [machine_stack_ptr] ; while (i > machine->stack_ptr)
    JLE machine_allocate_loop_break
    MOV D, C                   ; 
    ADD D, B                   ; int is_allocated = machine->allocated[i]
    CMP [D], 0                 ; if !is_allocated
    JNZ machine_allocate_loop_find_false
    INC X
    JMP machine_allocate_loop_find_true
machine_allocate_loop_find_false:
    MOV X, 0
machine_allocate_loop_find_true:
    CMP X, A                   ; if consecutive_free_cells == size
    JZ machine_allocate_loop_break
    DEC B
    JNZ machine_allocate_loop_find
machine_allocate_loop_break:
    MOV Y, B                   ; int addr = i
    CMP Y, [machine_stack_ptr] ; if addr <= vm->stack_ptr then panic
    JLE machine_allocate_loop_panic
    MOV B, 0                   ; i = 0
machine_allocate_loop_mark:
    CMP B, A                   ; while ( i < size)
    JGE machine_allocate_ret
    MOV D, C                   ; int * loc = machine->allocated
    ADD D, B                   ; loc += i
    MOV [D], 1                 ; *loc = 1
    INC B
    JMP machine_allocate_loop_mark
machine_allocate_ret:
    MOV SP, BP
    POP BP
    POP Y
    POP X
    POP D
    POP C
    POP B
    POP A
    RET
machine_allocate_loop_panic:
    PUSH NO_FREE_MEMORY
    CALL _panic

;; double machine_free()
machine_free:
    PUSH B
    PUSH C
    PUSH D
    PUSH X
    PUSH BP
    MOV BP, SP
    CALL machine_pop         ; int addr = machine_pop() // C
    MOV C, A
    CALL machine_pop         ; int size = machine_pop() // A
    MOV B, 0                 ; int i = 0                // B
machine_free_loop:
    CMP B, A
    JL machine_free_ret
    MOV D,   C                 ; int d = addr + i
    ADD D, B
    MOV X, [machine_allocated]
    ADD X, D
    MOV [X], 0                 ; machine->allocated[addr + i] = false
    MOV X, [machine_memory]
    ADD X, D
    MOV [X], 0                 ; machine->memory[addr + i] = 0
    INC B
    JMP machine_free_loop
machine_free_ret:
    MOV SP, BP
    POP BP
    POP X
    POP D
    POP C
    POP B
    RET

;; void machine_push(int n)
;; push n to the stack
machine_push:
    PUSH A
    PUSH BP
    MOV BP, SP
    ;; if machine->allocated[machine->stack_ptr] !== 0 then panic
    MOV A, [machine_allocated]
    ADD A, [machine_stack_ptr]
    CMP [A], 0
    JNZ machine_push_panic
    MOV A, [machine_memory]
    ADD A, [machine_stack_ptr] ; ref = &machine->memory[machine->stack_ptr]
    MOV [A], [BP + 3]          ; *ref = n
    INC [machine_stack_ptr]    ; machine->stack_ptr++
    MOV SP, BP
    POP BP
    POP A
    RET 1
machine_push_panic:
    PUSH STACK_HEAP_COLLISION
    CALL _panic

;; int machine_pop()
;; pop n of the stack
machine_pop:
    PUSH B
    PUSH BP
    MOV BP, SP
    CMP [machine_stack_ptr], 0
    JZ machine_pop_panic
    MOV A, [machine_memory]    ; int * loc = machine->memory
    ADD A, [machine_stack_ptr] ; loc += machine->stack_ptr
    DEC A                      ; loc -= 1
    MOV B, [A]                 ; int b = *loc
    MOV [A], 0                 ; *loc = 0 // imo no need to zero out memory after a pop, if the location is read it should be expected to be garbage data
    DEC [machine_stack_ptr]    ; machine->stack_ptr--
    MOV A, B                   ; return values are set in the A register
    MOV SP, BP
    POP BP
    POP B
    RET
machine_pop_panic:
    PUSH STACK_UNDERFLOW
    CALL _panic

;; void machine_store(int size)
;; pop address of the stack
;; i is size - 1
;; for i until size
;;    pop value off the stack
;;    write it to address + i
machine_store:
    PUSH A
    PUSH B
    PUSH C
    PUSH D
    PUSH BP
    MOV BP, SP
    CALL machine_pop        ; int * addr = machine_pop()
    ADD A, [machine_memory] ; addr += vm->memory
    MOV C, A                ; // move addr to a different register
    MOV B, [BP + 6]         ; int i = size
    DEC B                   ; i -= 1
machine_store_loop:
    CMP B, 0                ; while (i >= 0)
    JL machine_store_ret
    CALL machine_pop        ;   int value = machine_pop()
    MOV D, C                ;   int * loc = addr
    ADD D, B                ;   loc += i
    MOV [D], A              ;   *loc = value
    DEC B                   ;   i--
    JMP machine_store_loop
machine_store_ret:
    MOV SP, BP
    POP BP
    POP D
    POP C
    POP B
    POP A
    RET 1

;; void machine_load(int size)
;; load size amount of integers from popped address
machine_load:
    PUSH A
    PUSH B
    PUSH C
    PUSH D
    PUSH BP
    MOV BP, SP
    CALL machine_pop        ; int * addr = machine_pop()
    ADD A, [machine_memory] ; addr += vm->memory
    MOV C, A                ; move addr to a different register
    MOV B, 0                ; int i = 0
machine_load_loop:
    CMP B, [BP + 6]         ; while (i < size)
    JGE machine_load_ret
    MOV D, C                ; int * loc = addr
    ADD D, B                ; loc += i
    PUSH [D]                ; int value = *loc
    CALL machine_push       ; machine_push(value)
    INC B                   ; i++
    JMP machine_load_loop
machine_load_ret:
    MOV SP, BP
    POP BP
    POP D
    POP C
    POP B
    POP A
    RET 1

;; void machine_add()
;; pop 2 values, add them and push the result
machine_add:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    ADD A, B
    PUSH A
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void machine_subtract()
;; pop 2 values, subtract them and push the result
machine_subtract:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    SUB A, B
    PUSH A
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void machine_multiply()
;; pop 2 values, multiply them and push the result
machine_multiply:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    MUL B                 ; will multiply register A with operand, result is a 32-bit integer in Y:A
    PUSH A
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void machine_divide()
;; pop 2 values, divide them and push the result
machine_divide:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    MOV Y, 0
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    DIV B                 ; will divide register Y:A with source, result in A, remainder in Y
    PUSH A
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; std.ok defines a small std library, there are some foreign function calls inside that have to be defined
;; pop 2 values, compare and push the logical result
;; void lt!(x, y)
lt:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    CMP A, B
    JGE lt_false
    PUSH 1
    JMP lt_return
lt_false:
    PUSH 0
lt_return:
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void le!(x, y)
le:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    CMP A, B
    JG le_false
    PUSH 1
    JMP le_return
le_false:
    PUSH 0
le_return:
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void gt!(x, y)
gt:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    CMP A, B
    JLE gt_false
    PUSH 1
    JMP gt_return
gt_false:
    PUSH 0
gt_return:
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; void ge!(x, y)
ge:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV B, A
    CALL machine_pop
    CMP A, B
    JL ge_false
    PUSH 1
    JMP ge_return
ge_false:
    PUSH 0
ge_return:
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; pop a value and print it
;; void prs!(s)
;; NOTE: The internal buffer can contain up to 40 words
;; NOTE: Will copy 8 words each HWI
;; TODO: probably easier to write our own buffer logic to make writes consistant between ticks
;; TODO: write strings instead of deligating to prc
;; https://github.com/simon987/Much-Assembly-Required/wiki/(Hardware)-Universal-Com-Port
prs:
    PUSH A
    PUSH B
    PUSH C
    PUSH BP
    MOV BP, SP
    MOV B, [machine_memory]     ; int * loc = machine->memory
    CALL machine_pop            ; int addr = machine_pop()
prs_loop:
    MOV C, B 
    ADD C, A                    ; loc += addr
    CMP [C], 0                  ; while (*loc !== 0)
    JZ prs_break
    PUSH [C]
    CALL machine_push
    CALL prc
    INC A                       ;  addr++
    JMP prs_loop
prs_break:
    MOV SP, BP
    POP BP
    POP C
    POP B
    POP A
    RET

;; void prn!(n)
;; implementation from: https://stackoverflow.com/a/3982700
;; no negative numbers, no bound checks
prn:
    PUSH A
    PUSH Y
    PUSH BP
    MOV BP, SP
    CALL machine_pop  ; pop value into
prn_loop:
    CMP A, 10         ; while (value >= 10)
    JL prn_break
    MOV Y, 0         ; zero out Y for the DIV op
    DIV 10           ; divide by 10, result in A, remainder in Y
    ADD Y, 0x30      ; convert remainder to ascii character
    PUSH Y
    CALL machine_push ; push it on the stack
    PUSH A
    CALL prc
    JMP prn_loop
prn_break:
    ADD A, 0x30
    CALL prc
    MOV SP, BP
    POP BP
    POP Y
    POP A
    RET

;; void prc!(ch)
;; TODO: use smarter logic to use the full 40 word buffer instead of cheesing it with sleep
prc:
    PUSH A
    PUSH B ; preserve B because the com port uses it to indicate success
    PUSH X
    PUSH BP
    MOV BP, SP
    CALL machine_pop
    MOV [prc_static_buffer], A
    MOV A, 3 ;; COMPORT_SELF_OUT
    MOV X, prc_static_buffer ;; address of 8 words to copy
    HWI 0x000D ;; hwid of UCP
    CALL _sleep ;; cheese it to write 1 character each tick
    MOV SP, BP
    POP BP
    POP X
    POP B
    POP A
    RET
prc_static_buffer: DW 8 DUP(0x00)

;; this function seems to be missing from std.ok, but is used in a few files
;; it prints a newline
;; void prend!()
prend:
    PUSH 10 ; '\n'
    CALL machine_push
    CALL prc
    RET

;; retrieve a character from stdin and push it on the stack
;; void getch!()
;; NOTE: seems like getch is expected to block so we emulate that behaviour
;; https://github.com/simon987/Much-Assembly-Required/wiki/(Hardware)-Keyboard
getch:
    PUSH A
    PUSH B
    PUSH BP
    MOV BP, SP
getch_fetch:
    MOV A, 1   ; KEYBOARD_FETCH_KEY
    HWI 0x0004 ; hwid of the keyboard
    ;; result in B
    CMP B, 0   ; if the result is zero there was no character in the keyboard buffer
    JNZ getch_ret
    CALL _sleep ; to prevent spinning and draining the server / have the server terminate our execution we use sleep
    JMP getch_fetch
getch_ret:
    PUSH B
    CALL machine_push
    MOV SP, BP
    POP BP
    POP B
    POP A
    RET

;; generated code starts here with a `main:` label
;; ...
;; generated code ends here with a `RET` instruction

;; after the generated code
; HEAP_START: DW 0 ; label to where the heap should start
fn1:
PUSH 0
CALL machine_push
PUSH 1
CALL machine_store
PUSH 0
CALL machine_push
PUSH 1
CALL machine_load
PUSH 1
CALL machine_push
PUSH 1
CALL machine_store
PUSH 1
CALL machine_push
PUSH 2
CALL machine_push
PUSH 1
CALL machine_store
PUSH 1
CALL machine_push
PUSH 1
CALL machine_load
begin_while_0:
CALL machine_pop
CMP A, 0
JZ end_while_0
PUSH 0
CALL machine_push
PUSH 0
CALL machine_push
PUSH 1
CALL machine_push
PUSH 1
CALL machine_store
PUSH 0
CALL machine_push
PUSH 2
CALL machine_push
PUSH 1
CALL machine_store
PUSH 1
CALL machine_push
PUSH 1
CALL machine_load
JMP begin_while_0
end_while_0:
PUSH 2
CALL machine_push
PUSH 1
CALL machine_load
begin_while_1:
CALL machine_pop
CMP A, 0
JZ end_while_1
PUSH 1
CALL machine_push
PUSH 0
CALL machine_push
PUSH 1
CALL machine_push
PUSH 1
CALL machine_store
PUSH 0
CALL machine_push
PUSH 2
CALL machine_push
PUSH 1
CALL machine_store
PUSH 2
CALL machine_push
PUSH 1
CALL machine_load
JMP begin_while_1
end_while_1:
RET ; COMPILER: return from fn1

fn2:
PUSH 3
CALL machine_push
PUSH 1
CALL machine_store
PUSH 4
CALL machine_push
PUSH 1
CALL machine_store
PUSH 4
CALL machine_push
PUSH 1
CALL machine_load
PUSH 3
CALL machine_push
PUSH 1
CALL machine_load
CALL fn3
CALL fn1
RET ; COMPILER: return from fn2

fn3:
PUSH 5
CALL machine_push
PUSH 1
CALL machine_store
PUSH 6
CALL machine_push
PUSH 1
CALL machine_store
PUSH 5
CALL machine_push
PUSH 1
CALL machine_load
PUSH 6
CALL machine_push
PUSH 1
CALL machine_load
CALL machine_subtract
PUSH 7
CALL machine_push
PUSH 1
CALL machine_store
PUSH 1
CALL machine_push
PUSH 8
CALL machine_push
PUSH 1
CALL machine_store
PUSH 7
CALL machine_push
PUSH 1
CALL machine_load
begin_while_2:
CALL machine_pop
CMP A, 0
JZ end_while_2
PUSH 0
CALL machine_push
PUSH 0
CALL machine_push
PUSH 7
CALL machine_push
PUSH 1
CALL machine_store
PUSH 0
CALL machine_push
PUSH 8
CALL machine_push
PUSH 1
CALL machine_store
PUSH 7
CALL machine_push
PUSH 1
CALL machine_load
JMP begin_while_2
end_while_2:
PUSH 8
CALL machine_push
PUSH 1
CALL machine_load
begin_while_3:
CALL machine_pop
CMP A, 0
JZ end_while_3
PUSH 1
CALL machine_push
PUSH 0
CALL machine_push
PUSH 7
CALL machine_push
PUSH 1
CALL machine_store
PUSH 0
CALL machine_push
PUSH 8
CALL machine_push
PUSH 1
CALL machine_store
PUSH 8
CALL machine_push
PUSH 1
CALL machine_load
JMP begin_while_3
end_while_3:
RET ; COMPILER: return from fn3

fn4:
PUSH 9
CALL machine_push
PUSH 1
CALL machine_store
PUSH 10
CALL machine_push
PUSH 1
CALL machine_store
PUSH 10
CALL machine_push
PUSH 1
CALL machine_load
PUSH 9
CALL machine_push
PUSH 1
CALL machine_load
CALL lt
RET ; COMPILER: return from fn4

fn5:
PUSH 11
CALL machine_push
PUSH 1
CALL machine_store
PUSH 12
CALL machine_push
PUSH 1
CALL machine_store
PUSH 12
CALL machine_push
PUSH 1
CALL machine_load
PUSH 11
CALL machine_push
PUSH 1
CALL machine_load
CALL le
RET ; COMPILER: return from fn5

fn6:
PUSH 13
CALL machine_push
PUSH 1
CALL machine_store
PUSH 14
CALL machine_push
PUSH 1
CALL machine_store
PUSH 14
CALL machine_push
PUSH 1
CALL machine_load
PUSH 13
CALL machine_push
PUSH 1
CALL machine_load
CALL gt
RET ; COMPILER: return from fn6

fn7:
PUSH 15
CALL machine_push
PUSH 1
CALL machine_store
PUSH 16
CALL machine_push
PUSH 1
CALL machine_store
PUSH 16
CALL machine_push
PUSH 1
CALL machine_load
PUSH 15
CALL machine_push
PUSH 1
CALL machine_load
CALL ge
RET ; COMPILER: return from fn7

fn8:
PUSH 17
CALL machine_push
PUSH 1
CALL machine_store
PUSH 17
CALL machine_push
PUSH 1
CALL machine_load
CALL prs
RET ; COMPILER: return from fn8

fn9:
PUSH 18
CALL machine_push
PUSH 1
CALL machine_store
PUSH 18
CALL machine_push
PUSH 1
CALL machine_load
CALL fn8
PUSH 10
CALL machine_push
PUSH 0
CALL machine_push
PUSH 19
CALL machine_push
PUSH 2
CALL machine_store
PUSH 19
CALL machine_push
CALL fn8
RET ; COMPILER: return from fn9

fn10:
PUSH 21
CALL machine_push
PUSH 1
CALL machine_store
PUSH 21
CALL machine_push
PUSH 1
CALL machine_load
CALL prn
RET ; COMPILER: return from fn10

fn11:
PUSH 22
CALL machine_push
PUSH 1
CALL machine_store
PUSH 22
CALL machine_push
PUSH 1
CALL machine_load
CALL fn10
PUSH 10
CALL machine_push
PUSH 0
CALL machine_push
PUSH 23
CALL machine_push
PUSH 2
CALL machine_store
PUSH 23
CALL machine_push
CALL fn8
RET ; COMPILER: return from fn11

fn12:
PUSH 25
CALL machine_push
PUSH 1
CALL machine_store
PUSH 25
CALL machine_push
PUSH 1
CALL machine_load
CALL prc
RET ; COMPILER: return from fn12

fn13:
PUSH 26
CALL machine_push
PUSH 1
CALL machine_store
PUSH 26
CALL machine_push
PUSH 1
CALL machine_load
CALL fn12
PUSH 10
CALL machine_push
PUSH 0
CALL machine_push
PUSH 27
CALL machine_push
PUSH 2
CALL machine_store
PUSH 27
CALL machine_push
CALL fn8
RET ; COMPILER: return from fn13

fn14:
CALL getch
RET ; COMPILER: return from fn14

fn0:
PUSH 72
CALL machine_push
PUSH 101
CALL machine_push
PUSH 108
CALL machine_push
PUSH 108
CALL machine_push
PUSH 111
CALL machine_push
PUSH 32
CALL machine_push
PUSH 119
CALL machine_push
PUSH 111
CALL machine_push
PUSH 114
CALL machine_push
PUSH 108
CALL machine_push
PUSH 100
CALL machine_push
PUSH 33
CALL machine_push
PUSH 0
CALL machine_push
PUSH 29
CALL machine_push
PUSH 13
CALL machine_store
PUSH 29
CALL machine_push
CALL prs
RET ; COMPILER: return from fn0

_machine_new_vars: DW 42
_machine_new_capacity: DW 554
main:
CALL fn0
    RET
HEAP_START:

;;/
;; Hardware - Universal Communication Port (UCP or comport)
;; Address:   0x000D
;; Id:        0x000D
;; Docs:      https://github.com/simon987/Much-Assembly-Required/wiki/(Hardware)-Universal-Com-Port
;; NOTE: a #[sleep] attribute can call the the `__core_sleep` routine one or more times before returning execution to the caller
;;/

;; NOTE: i try to be smart and use as few instructions as possible. It might be a bad idea, but id like to try and keep the stdlib as compact as possible

__MAR_HWID_COMPORT equ 0x000D

__MAR_COMPORT_BUFFER_CLEAR   equ 0 ;; / Clears the internal buffer
__MAR_COMPORT_POLL           equ 1 ;; / Copy all internal buffer messages to address X, sets B to the number of messages copied
__MAR_COMPORT_FRONT_PORT_OUT equ 2 ;; / Copies 8 words starting at address X to the front port if there is a valid receiver present. Sets/resets B to indicate success
__MAR_COMPORT_SELF_OUT       equ 3 ;; / Copies 8 words starting at address X to the internal message buffer. Sets/resets B to indicate success
__MAR_COMPORT_CONSOLE_CLEAR  equ 4 ;; / Clears the console

__MAR_COMPORT_BUFFER_SIZE equ 40

;; static char[40] __mar_comport_buffer
;; MAR assembler does not support using constants in dw or dup
__mar_comport_buffer: dw 40 dup(0x0000)
;; static unsigned int __mar_comport_buffer_length
__mar_comport_buffer_length: dw 0x0000

;; int  __mar_comport_flush()
;; tries to flush the contents of `__mar_comport_buffer` to the internal hardware buffer
;; returns a 0 on failure, a non-zero value on success
;; NOTE: the hardware can only have 40 characters in its internal buffer. It only gets cleared on a new game tick.
__mar_comport_flush:
    ;; preserve B and X
    push B
    push X
    push Y
    mov A, __MAR_COMPORT_SELF_OUT
    mov X, __mar_comport_buffer
__mar_comport_flush_loop:
    ;; TODO: we really shouldnt flush the whole buffer contents. only multiples of 8 up until the length
    ;; because `__mar_comport_buffer_length` is located right after the BUFFER, we can just do a pointer comparison
    cmp X, __mar_comport_buffer_length
    jz  __mar_comport_flush_return
    hwi __MAR_HWID_COMPORT
    cmp B, 0
    jz __mar_comport_flush_error
    ;; zero out the written 8 words
    mov B, X
    add X, 8
__mar_comport_flush_clear_loop:
    cmp B, X
    jz  __mar_comport_flush_loop
    mov [B], 0
    inc B
    jmp  __mar_comport_flush_clear_loop
__mar_comport_flush_error:
    ;; set the error return value
    mov A, 0
    ;; if there is an error we want 'shift' the remaining characters to the start of the buffer and set the length accordingly
    mov B, __mar_comport_buffer
    mov Y, X
__mar_comport_flush_error_shift_loop:
    cmp B, Y
    jz __mar_comport_flush_error_reset_length
    mov [B], [X]
    inc B
    inc X
    jmp __mar_comport_flush_error_shift_loop
__mar_comport_flush_error_reset_length:
    ;; reset the length
    mov [__mar_comport_buffer_length], B
    sub [__mar_comport_buffer_length], __mar_comport_buffer
__mar_comport_flush_error_clear_loop:
    ;; and zero out the remainder
    cmp B, __mar_comport_buffer_length
    mov [B], 0
    inc B
    jz  __mar_comport_flush_return
    jmp __mar_comport_flush_error_clear_loop
 __mar_comport_flush_return:
    ;; if there was no failure the value of A is still COMPORT_SELF_OUT (3) and thus a valid return value for success
    ;; preserve B and X
    pop Y
    pop X
    pop B
    ret

;; size_t __mar_comport_write(const char * str, size_t length)
;; tries to write the `length` amount of characters from `str` to the `__mar_comport_buffer`
;; returns the number of characters written
;; NOTE: `__mar_comport_buffer_length` will never decrement unless ` __mar_comport_flush` is called
__mar_comport_write:
    ;; preverse B
    push B
    push BP
    mov BP, SP
    ;; [BP + 0] = old BP
    ;; [BP + 1] = old B
    ;; [BP + 2] = return address
    ;; [BP + 3] = const char * str
    ;; [BP + 4] = size_t length
    ;; const char * source = str
    mov A, [BP + 3]
    ;; char * dest = __mar_comport_buffer
    mov B, __mar_comport_buffer
    ;; dest += *__mar_comport_buffer_length
    add B, [__mar_comport_buffer_length]
__mar_comport_write_loop:
    ;; if we have copied `length` amount of characters we are done
    cmp [BP + 4], 0
    jz __mar_comport_write_return
    ;; if we cannot write more characters to the buffer we return early
    ;; because `__mar_comport_buffer_length` is located right after the bfufer, we can just do a pointer comparison
    cmp B, __mar_comport_buffer_length
    jz __mar_comport_write_return
    ;; *dest = *source
    mov [B], [A]
    inc A
    inc B
    dec [BP + 4]
    jmp __mar_comport_write_loop
__mar_comport_write_return:
    ;; so A is somewhere inside the string where we stopped writing
    ;; if we do `loc - str` we get the amount of characters written inside our return register
    sub A, [BP + 3]
    ;; add the written amount of characters to `*__mar_comport_buffer_length`
    add [__mar_comport_buffer_length], A
    mov SP, BP
    pop BP
    pop B
    ret 2

;; #[sleep] size_t __mar_comport_write_blocking(const char * str, size_t length)
;; writes the `length` amount of characters from `str` to the `__mar_comport_buffer`
;; it blocks execution until all characters have been written to the internal hardware buffer
;; it might take one more ticks before execution returns
;; returns the number of characters written
__mar_comport_write_blocking:
    push B
    push BP
    mov BP, SP
    ;; [BP + 0] = old BP
    ;; [BP + 1] = old B
    ;; [BP + 2] = return address
    ;; [BP + 3] = const char * str
    ;; [BP + 4] = size_t length
    mov B, [BP + 3]                          ; const char * src
__mar_comport_write_blocking_loop:           ;
    cmp [BP + 4], 0                          ; while (length != 0)
    jz __mar_comport_write_blocking_flush_before_return
    push [BP + 4]                            ; 
    push B                                   ;
    call __mar_comport_write                 ;     size_t amount_written = __mar_comport_write(src, length)
    add B, A                                 ;     src += amount_written
    sub [BP + 4], A                          ;     length -= amount_written
    cmp [__mar_comport_buffer_length], __MAR_COMPORT_BUFFER_SIZE
    jz __mar_comport_write_blocking_flush
    jmp __mar_comport_write_blocking_loop
__mar_comport_write_blocking_flush:
    call __mar_comport_flush 
    call __core_sleep
    cmp A, 0
    ;; TODO: rewrite the clearing of [__mar_comport_buffer_length], preferably flush with  pre_sleep hook and reset length with a post_sleep hook
    jz __mar_comport_write_blocking_flush    ; if flushing failed, the flush call itself will adjust the length and buffer contents
    mov [__mar_comport_buffer_length], 0     ; if the flushing did not fail
    jmp __mar_comport_write_blocking_loop
__mar_comport_write_blocking_flush_before_return:
    cmp [__mar_comport_buffer_length], 0
    jz __mar_comport_write_blocking_return
    call __mar_comport_flush
__mar_comport_write_blocking_return:
    mov A, B
    sub B, [BP + 3]
    mov SP, BP
    pop BP
    pop B
    ret 2

;;; NOTE: the functions ABOVE abstract the direct hardware interface to implement basic functionality
;;; NOTE: the functions BELOW give direct access to the hardware interface

;; void __mar_comport_buffer_clear()
;; clears the internal hardware message buffer
;; NOTE: this is a different (unreachable) buffer than `__mar_comport_buffer`
__mar_comport_buffer_clear:
    ;; TODO: implement
    ret

;; size_t __mar_comport_poll(char * dest)
;; 
;; NOTE: this is an unsafe function because if dest is pointing to 40 reserved words it will overflow
;; TODO: maybe write a safe version with a static 40 words buffer to write into, then write `size_t length` amount of characters to the destination
__mar_comport_poll:
    ;; TODO: implement
    ret

;; bool __mar_comport_front_port_out(const char * source)
__mar_comport_front_port_out:
    ;; TODO: implement
    ret

;; bool __mar_comport_self_out(const char * source)
__mar_comport_self_out:
    ;; TODO: implement
    ret

;; void __mar_comport_console_clear()
;; clears the console
__mar_comport_console_clear:
    ;; TODO: implement
    ret

;; NOTE: the compiler will hoist __CORE_GLOBAL_SCOPE_SIZE and __CORE_INIT_VM_CAPACITY as a prefix to the contents of this file

;; we want the runtime to be be able to host 'itself' by not depending on any dependencies
;; it should only implement the vm and any nessesary code and variables to run the oak program
;; the only overhead it currently contains is having a function pointer table for initializer functions
;; core only uses 1 entry, the rest of the entries can be filled during a 'linking' process to hook into this initializer feature

;; Setting the binary offset to 0 makes sure our .data section starts at address 0x0000
org 0

;; data segment -
;; NOTE: the _0x00xx labels are just to help visualize the offsets
;; NOTE: there are some static variables scattered trough the source, decide on what stays static inline and what can move to the data section
.data
_0x0000:
    __core_interrupt_vector_table:
    ;; division by zero causes an interrupt
    __core_interrupt_divide_by_zero: dw __core_interrupt_handler_default
_0x0001:
    ;; not implemented
    __core_interrupt_trap: dw __core_interrupt_handler_default
_0x0002:
    ;; not implemented
    __core_interrupt_nmi: dw __core_interrupt_handler_default
_0x0003:
    ;; NOTE: INT 3 is a special case for the server that starts the debugging mode.
    ;; NOTE: This memory location will never actually be used as a jump location for an interrupt
    ;; TODO: use this location for a static variable so we dont waste its space
    ;; not implemented server
    __core_interrupt_break_point: dw __core_interrupt_handler_default
_0x0004:
    ;; this interrupt requires a INTO instruction and the overflow flag to be set
    __core_interrupt_integer_overflow: dw __core_interrupt_handler_default
_0x0005:
    ;; keep 0x05 - 0x1F reserved for future interrupt handlers
    dw 0x1B dup(0x0153)
_0x0020:
    ;; MAR server causes this interrupt when the cpu is not allowed to execute any more instructions
    ;; gives 10_0000 instructions to save state and brk.
    ;; If execution is forcibly stopped the behaviour of the runtime is undefined
    __core_interrupt_execution_limit_reached: dw __core_interrupt_handler_execution_limit_reached
_0x0021:
    ;; keep 0x20 - 0x3f reserverd for future (hardware) interrupt handlers
    __core_interrupt_vector_table_hardware: dw 0x001F dup(0x0153)
_0x0040:
    ;; keep 0x40 - 0x43 reserved for core interrupt handlers
    __core_interrupt_vector_table_core:
    ;; software interrupt for a panic of unkown reason
    __core_interrupt_panic_unkown: dw __core_interrupt_handler_default
_0x0041:
    ;; software interrupt for a panic caused by a stack and heap collision
    __core_interrupt_panic_stack_heap_collision: dw __core_interrupt_handler_panic_stack_heap_collision
_0x0042:
    ;; software interrupt for a panic caused by having no more free memory
    __core_interrupt_panic_no_free_memory: dw __core_interrupt_handler_panic_no_free_memory
_0x0043:
    ;; software interrupt for a panic caused by a stack underflow
    __core_interrupt_panic_stack_underflow: dw __core_interrupt_handler_panic_stack_underflow
    ;; 0x44 - 0x7f is open for software interrupts
_0x0044:
    __core_interrupt_vector_table_software:
    dw 0x3C dup(0x0153)
    ;; TODO: figure out how the stdlib is going to reserve interrupts
    ;; probably by owning the software interrupt table and providing an interface to interact with it
_0x0080:
    __core_initializer_vector_table:
    ;; NOTE: when altering the table, the padding after the struct has to be adjusted as well.
    ;; struct __core_initializer_vector_table {
    ;;   size_t length
    __core_initializer_vector_table_length: dw 1
    ;;   void * entries
    __core_initializer_vector_table_entries: dw __core_machine_new
    ;; }
    ;; unused padding (0xdead is a value that is easily recognized)
    dw 0x76 dup(0xdead)
_0x00F8:
    ;; static variables used by __core_* functions
    ;; static struct machine {
    __core_vm:
    ;;   int * memory
    __core_vm_memory: dw 0x0000
    ;;   bool * allocated
    __core_vm_allocated: dw 0x0000
    ;;   size_t capacity
    __core_vm_capacity: dw 0x0000
    ;;   size_t base_ptr
    __core_vm_base_ptr: dw 0x0000
    ;;   size_t stack_ptr
    __core_vm_stack_ptr: dw 0x0000
    ;; } vm;
    ;; static const char * __core_panic_unkown_message
    __core_panic_unkown_message: dw "\nERR_UNKNOWN", 0 ;; 13 length
    ;; static const char * __core_panic_stack_heap_collision
    __core_panic_stack_heap_collision: dw "\nERR_STACK_HEAP_COLLISION", 0 ;; 26 length
    ;; static const char * __core_panic_no_free_memory
    __core_panic_no_free_memory: dw "\nERR_NO_FREE_MEMORY", 0 ;; 20 length
    ;; static const char * __core_panic_stack_underflow
    __core_panic_stack_underflow: dw "\nERR_STACK_UNDERFLOW", 0 ;; 21 length
    ;; static void * __core_jump_on_wake
    __core_jump_on_wake: dw 0x0000 ;; 0 represents no jump, non-0 represent a jump location
    ;; static size_t __core_execution_limit_reached_saved_sp
    __core_execution_limit_reached_saved_sp: dw 0
    ;; static size_t __core_execution_limit_reached_saved_bp
    __core_execution_limit_reached_saved_bp: dw 0
_0x0150:
    ;; 3 words reserved for execution cost variables. These are set by the server executing the code
    ;; see https://github.com/simon987/Much-Assembly-Required/blob/master/Server/src/main/java/net/simon987/server/assembly/CPU.java#L194
    __core_execution_cost_addr: dw 0x0000
    ;; 32 bit signed integer
    __core_executed_instruction_count: dw 0x0000, 0x0000

_0x0153:
;; #[interrupt_handler] #[no_return] void __core_interrupt_handler_default()
;; this handler can be used as the default address for interrupt handlers
;; this prevents unhandled interrupts from jumping to random locations
__core_interrupt_handler_default:
    ;; currently the label just falls trough to the panic_unkown handler

;; #[interrupt_handler] void __core_interrupt_handler_panic_unkown()
__core_interrupt_handler_panic_unkown:
    push 0
    call __core_panic
    
__CORE_STACK_HEAP_COLLISION EQU 1
__CORE_NO_FREE_MEMORY EQU 2
__CORE_STACK_UNDERFLOW EQU 3

_0x0157:
;; #[interrupt_handler] #[no_return] void __core_interrupt_handler_panic_stack_heap_collision()
__core_interrupt_handler_panic_stack_heap_collision:
    push __CORE_STACK_HEAP_COLLISION
    call __core_panic
_0x015B:
;; #[interrupt_handler] #[no_return] void __core_interrupt_handler_panic_no_free_memory()
__core_interrupt_handler_panic_no_free_memory:
    push __CORE_STACK_HEAP_COLLISION
    call __core_panic
_0x015F:
;; #[interrupt_handler] #[no_return] void __core_interrupt_handler_panic_stack_underflow()
__core_interrupt_handler_panic_stack_underflow:
    push __CORE_STACK_UNDERFLOW
    call __core_panic
_0x0163:

;; #[interrupt_handler] void __core_interrupt_handler_execution_limit_reached()
;; this has to be in core to make sure a program keeps its execution state in between ticks
;; std can overwrite the interupt vector entry to a different location to add more features (like a __mar_comport_flush call)
__core_interrupt_handler_execution_limit_reached:
    push a
    push b
    push c
    push d
    push x
    push y
    mov [__core_execution_limit_reached_saved_sp], sp
    mov [__core_execution_limit_reached_saved_bp], bp
    mov [__core_jump_on_wake], __core_interrupt_handler_execution_limit_reached_on_wake
    call __mar_comport_flush ;; TODO: remove this from core
    brk
__core_interrupt_handler_execution_limit_reached_on_wake:
    mov bp, [__core_execution_limit_reached_saved_bp]
    mov sp, [__core_execution_limit_reached_saved_sp]
    pop y
    pop x
    pop d
    pop c
    pop b
    pop a
    iret

;; #[no_return] void __core_panic(int error_code)
;; prints a user friendly error message and then exits the program
;; in our case this means spinning forever
__core_panic:
    ;; [SP] = return address
    ;; [SP + 1] = int error_code
    MOV A, [SP + 1]
    mov X, __core_panic_unkown_message
__core_panic_case_1:
    cmp A, 1
    jnz __core_panic_case_2
    mov X, __core_panic_stack_heap_collision
    jmp __core_panic_end
__core_panic_case_2:
    cmp A, 2
    jnz __core_panic_case_3
    mov X, __core_panic_no_free_memory
    jmp __core_panic_end
__core_panic_case_3:
    cmp A, 3 
    jnz __core_panic_end
    mov X, __core_panic_stack_underflow
__core_panic_end:
    mov A, 3 ;; COMPORT_SELF_OUT
__core_panic_write:
    hwi 0x0D ;; HWID_COMPORT
    xor B, B ;; reset b
__core_panic_scan:
    inc X
    inc B
    cmp [X], 0 ;; this copies a null terminated string to the comport's internal buffer, then spins
    jz __core_spin
    cmp B, 8
    jz __core_panic_write
    jmp __core_panic_scan

;; void __core_machine_new()
;; initializes the virtual machine located at the label __core_vm
;; we expected a label to be at the end of all code named `__core_heap_start`
__core_machine_new:
    ;; TODO: write an heap implementation that doesnt have a 100% memory overhead
    ;; compiler figures out how big the tape must be and defines it as `__core_init_vm_capacity: dw value`
    mov [__core_vm_capacity], __CORE_INIT_VM_CAPACITY
    ;; vm->memory is a pointer to the __core_heap_start address
    mov [__core_vm_memory], __core_heap_start

    ;; vm->allocated  is a pointer to the __core_heap_start address with an offset of vm->capacity
    mov [__core_vm_allocated], __core_heap_start
    add [__core_vm_allocated], [__core_vm_capacity]
    ;; compiler figures out how big the stack can be and defines it as `__core_global_scope_size: dw value`
    ;; the c impl does a for loop with push(0) for this size, but the end result is the same as setting the stack ptr to this size
    mov [__core_vm_stack_ptr], __CORE_GLOBAL_SCOPE_SIZE
    ret

;; void __core_machine_allocate()
;; pop size of the stack
__core_machine_allocate:
    push A
    push B
    push C
    push D
    push X
    push Y
    push BP
    mov BP, SP
    mov a, 0
    ;; call __core_machine_pop
    mov B, [__core_vm_capacity]  ; int i = vm->capacity
    dec B                        ; i -= 1
    mov C, [__core_vm_allocated] ; int * loc_allocated = vm->allocated
    xor X, X                     ; int consecutive_free_cells = 0
    xor Y, Y                     ; addr = 0
__core_machine_allocate_loop_find:
    cmp B, [__core_vm_stack_ptr] ; while (i > vm->stack_ptr)
    jle __core_machine_allocate_loop_break
    mov D, C                     ; 
    add D, B                     ; int is_allocated = vm->allocated[i]
    cmp [D], 0                   ; if is_allocated == 0
    jz __core_machine_allocate_loop_cell_free
    xor x, x
    jmp __core_machine_allocate_loop_check
__core_machine_allocate_loop_cell_free:
    inc x
__core_machine_allocate_loop_check:
    cmp X, A
    jz __core_machine_allocate_loop_break_success
    dec b
    jmp __core_machine_allocate_loop_find
__core_machine_allocate_loop_break_success:
    mov Y, B                   ; int addr = i
__core_machine_allocate_loop_break:
    cmp Y, [__core_vm_stack_ptr] ; if addr <= vm->stack_ptr then panic
    jle __core_machine_allocate_loop_panic
    xor B, B                   ; i = 0
__core_machine_allocate_loop_mark:
    cmp B, A                   ; while (i < size)
    jge __core_machine_allocate_return
    mov D, C                   ; int * loc = vm->allocated
    add D, Y                   ; loc += addr
    add D, B                   ; loc += i
    mov [D], 1                 ; *loc = 1
    inc B
    jmp __core_machine_allocate_loop_mark
__core_machine_allocate_return:
    push Y
    mov SP, BP
    pop BP
    pop Y
    pop X
    pop D
    pop C
    pop B
    pop A
    ret
__core_machine_allocate_loop_panic:
    int __core_interrupt_panic_no_free_memory

;; void __core_machine_free()
__core_machine_free:
    push B
    push C
    push D
    push X
    push BP
    mov BP, SP
    mov a, 0
    ;;call __core_machine_pop         ; int addr = __core_machine_pop() // C
    mov C, A
    mov a, 0
    ;;call __core_machine_pop         ; int size = __core_machine_pop() // A
    xor B, B                 ; int i = 0                // B
__core_machine_free_loop:
    cmp B, A
    jl __core_machine_free_return
    mov D,   C                 ; int d = addr + i
    add D, B
    mov X, [__core_vm_allocated]
    add X, D
    mov [X], 0                 ; vm->allocated[addr + i] = false
    mov X, [__core_vm_memory]
    add X, D
    mov [X], 0                 ; vm->memory[addr + i] = 0
    inc B
    jmp __core_machine_free_loop
__core_machine_free_return:
    mov SP, BP
    pop BP
    pop X
    pop D
    pop C
    pop B
    ret

;; execution on a server tick always starts at .text with the registers and status flags reset
;; a server reset erase the memory and floppy contents
;; #[entry] void __core_start()
.text
__core_start:
    ;; if * __core_jump_on_wake != null then jump to that pointer
    cmp [__core_jump_on_wake], 0
    jnz [__core_jump_on_wake]

    ;; setup a loop to call all intializer functions
__core_start_initialize_runtime:
    xor a, a                                          ; size_t i = 0
__core_start_initialize_runtime_loop:
    cmp a, [__core_initializer_vector_table_length]   ; while (i != __core_initializer_vector_table_length)
    jz __core_start_runtime_is_initialized
    mov b, __core_initializer_vector_table_entries    ; void (*func)() = __core_initializer_vector_table_entries[i]
    add b, a
    call [b]                                            ; (*func)()
    inc a                                             ; i++
    jmp __core_start_initialize_runtime_loop

__core_start_runtime_is_initialized:
    ;; call the user defined enry point
    call __core_main

    ;; set the __core_jump_on_wake pointer to the next instruction
    ;; by using a simple pointer to represent a jump location if not null
    ;; any implementation can use `__core_jump_on_wake` and `brk` to implement a sleep and wake implementation with more features
__core_spin:
    mov [__core_jump_on_wake], __core_brk
__core_brk:
    brk

;; the compiler will genererate the following:
;; oak program entrypoint. after the runtime is initialized it will call this function
;; __core_main:
